{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is the documentation for the <code>Djapy</code> library, which is designed to let you make RESTful APIs within Django with as no boilerplate, using plain Python and Django, with the supremacy of Pydantic.</p> <p>Djapy is molded according to <code>Django</code>'s philosophy of \"batteries included\", and is designed to be as simple as possible to use, while still being powerful enough to handle most use cases.</p> <pre><code>@djapify\ndef get_user(request) -&gt; {200: UserSchema, 404: str}:\n    return request.user\n</code></pre> <p>It's that simple!</p>"},{"location":"#installation","title":"Installation","text":"<p>Djapy is available on PyPI, and can be installed with <code>pip</code>:</p> <pre><code>pip install djapy\nor\npip install git+https://github.com/Bishwas-py/djapy.git@main # for the latest version\n</code></pre>"},{"location":"#creating-a-new-project","title":"Creating a new project","text":"<p>To create a new project, run the following command:</p> <pre><code>django-admin startproject &lt;project_name&gt;\n</code></pre> <p>More on this in the Getting Started section.</p>"},{"location":"auth/","title":"Auth, well that's a thing","text":"<p>Authentication is super critical for any application. It's the process of verifying the identity of a user. In this section, we'll cover how to authenticate users in your application.</p>"},{"location":"auth/#session-authentication","title":"Session Authentication","text":"<p>Session authentication is the default authentication mechanism for Django, and Djapy supports it out of the box.</p> <p>To use session authentication, you need to import <code>SessionAuth</code> from <code>djapy.auth</code> and utilize it in your views.</p> <pre><code>from djapy import SessionAuth\n\n\n@djapy_auth(SessionAuth, permissions=['plans.todos.can_view'])\ndef todo_list(request):\n    ...\n</code></pre> <p>or if you wanna assign authentication to the all endpoints in your <code>views.py</code> file, you can use <code>AUTH_MECHANISM</code> variable.</p> <pre><code>AUTH_MECHANISM = SessionAuth(permissions=['plans.todos.can_view'])\n# or just SessionAuth\n</code></pre>"},{"location":"auth/#extending-base-authentication","title":"Extending Base Authentication","text":"<p>You can extend the base authentication mechanism to create your own custom authentication mechanism.</p> <p>Here's an example of how you can do that:</p> <pre><code>from djapy import BaseAuthMechanism\n\n\nclass CustomAuth(BaseAuthMechanism):\n    def __init__(self, permissions):\n        self.permissions = permissions\n\n    def authenticate(self, request):\n        # Your custom authentication logic here\n        return True\n\n    def authorize(self, request):\n        # Your custom authorization logic here\n        return True\n\n    def schema(self):\n        return {}  # Your custom schema here to be used in the swagger documentation\n\n    def app_schema(self):\n        return {}  # Your custom app schema here to be used in the swagger documentation\n</code></pre>"},{"location":"pagination/","title":"Pagination","text":"<p>You want something, djapily paginated? Right place you're in.</p> <p>We provide three pagination out of the box; <code>OffsetLimitPagination</code>, <code>PageNumberPagination</code> and <code>CursorPagination</code>.</p>"},{"location":"pagination/#offsetlimitpagination","title":"OffsetLimitPagination","text":"<p>This is the default pagination mechanism in Djapy. It's simple and easy to use. It's based on the <code>offset</code> and <code>limit</code> query parameters. Here's how you can use it:</p> <pre><code>from djapy.pagination import OffsetLimitPagination, paginate\n\n\n@djapify  # required\n@paginate(OffsetLimitPagination)  # required, OR just @paginate, params: offset=0, limit=10\ndef todo_list(request, **kwargs) -&gt; List[Todo]:\n    return Todo.objects.all()\n</code></pre> <p>Make sure to add <code>paginate</code> decorator to your view and pass the pagination class as an argument. <code>List[Todo]</code> is the return type hint of the view, also for Swagger documentation.</p> <p><code>**kwargs</code> is required to pass the pagination parameters to the view.</p>"},{"location":"pagination/#pagenumberpagination","title":"PageNumberPagination","text":"<p>This is another pagination mechanism in Djapy. It's based on the <code>page</code> and <code>page_size</code> query parameters. Here's how you can use it:</p> <pre><code>from djapy.pagination import PageNumberPagination, paginate\n\n\n@djapify  # required\n@paginate(PageNumberPagination)  # required, OR just @paginate, params: page_number=1, page_size=10\ndef todo_list(request, **kwargs) -&gt; List[Todo]:\n    return Todo.objects.all()\n</code></pre>"},{"location":"pagination/#cursorpagination","title":"CursorPagination","text":"<p>This is the last pagination mechanism in Djapy. It's based on the <code>cursor</code> query parameter. Here's how you can use it:</p> <pre><code>from djapy.pagination import CursorPagination, paginate\n\n\n@djapify  # required\n@paginate(CursorPagination)  # required, OR just @paginate, params: cursor=0, limit=10\ndef todo_list(request, **kwargs) -&gt; List[Todo]:\n    return Todo.objects.all()\n</code></pre> <p><code>cursor</code> is the primary key of the last object in the previous page.</p>"},{"location":"pagination/#extending-base-pagination","title":"Extending Base Pagination","text":"<p>You can extend the base pagination mechanism to create your own custom pagination mechanism.</p> <p>Here's an example of how you can do that:</p> <pre><code>from djapy.pagination import BasePagination\nfrom pydantic import model_validator\n\n\nclass CursorPagination(BasePagination):  # example\n    \"\"\"Cursor-based pagination.\"\"\"\n\n    query = [\n        ('cursor', conint(ge=0), 0),\n        ('limit', conint(ge=0), 1),\n        # ... your custom query parameters here\n    ]\n\n    class response(Schema, Generic[G_TYPE]):\n        items: G_TYPE\n        cursor: int | None\n        limit: int\n        has_next: bool\n\n        # ... your custom fields here\n\n        @model_validator(mode=\"before\")\n        def make_data(cls, queryset, info):\n            if not isinstance(queryset, QuerySet):\n                raise ValueError(\"The result should be a QuerySet\")\n            # ... your custom logic here\n\n            return {\n                \"items\": queryset_subset,\n                \"cursor\": cursor,\n                \"limit\": limit,\n                \"has_next\": has_next,\n            }\n</code></pre>"},{"location":"swagger/","title":"Swagger, swagger there you are","text":"<p>Well, djapy, one of the finest piece of software I've ever written, has a swagger documentation. It is flawless, it is perfect, it is beautiful.</p> <p>Here's how it looks like:</p> <p></p> <p>And here's how you can use it:</p> <pre><code>from django.urls import path\nfrom djapy import openapi\n\nopenapi.set_basic_info(\n    title=\"Todo API\",\n    description=\"A simple todo API\",\n    version=\"0.0.1\",\n    tags_info=[\n        {\"name\": \"Todos\", \"description\": \"Operations related to todos\"}\n    ]\n)\n\nurlpatterns = [\n    ...\n    path('', openapi.urls),\n]\n</code></pre> <p>And that's it. You can now access your swagger documentation at the url you've set in your <code>urls.py</code> file.</p>"},{"location":"swagger/#tags-and-descriptions","title":"Tags and descriptions","text":"<p>You can add tags to whole endpoints in your <code>views.py</code> using the <code>TAGS</code> variable.</p> <pre><code>TAGS = [\"Todos\"]\n\n\n@djapify\ndef todo_list(request):\n    ...\n</code></pre> <p>Also, you can assign tags specifically using <code>@djapigy</code> decorator.</p> <pre><code>from djapy import djapify\n\n\n@djapify(tags=[\"todos\"])\ndef todo_list(request):\n    ...\n</code></pre> <p>It's that simple.</p>"},{"location":"usage/","title":"Usage","text":"<p>Here's how you can use this package:</p> <pre><code>@djapify\ndef get_user(request, data: UserCreationSchema) -&gt; {200: UserSchema, 404: MessageOut}:\n    if request.user.has_perm('users.can_create_user'):\n        user = User.objects.create_user(username=data.username, email=data.email)\n        return user\n    else:\n        return {\n            'message': 'You are not allowed to create a user',\n            'alias': 'not_allowed'\n        }\n    return request.user  # or 200, request.user\n</code></pre> <ul> <li><code>djapify</code> is a decorator that takes a function and returns a new function that can be used as a Django view.</li> <li>The function signature is <code>def get_user(request, data: UserCreationSchema) -&gt; {200: UserSchema, 404: MessageOut}:</code><ul> <li>The first argument is always the request object.</li> <li>The rest of the arguments are the parameters that you want to accept from the request.</li> <li>The return type is a dictionary that maps status codes to Schema[Pydantic models].</li> </ul> </li> <li>The function body can be anything you want, as long as it returns a dictionary that maps status codes to Pydantic   models.   3</li> </ul>"},{"location":"usage/#request","title":"Request","text":"<p>The schema is defined using Pydantic models. Here's an example:</p> <pre><code># schemas.py\nfrom djapy import Schema\n\n\nclass CreateUserSchema(Schema):\n    username: str\n    email: EmailStr\n\n\n# views.py\n@djapify\ndef create_user(request, data: CreateUserSchema) -&gt; {200: UserSchema, 400: str}:\n    user = User.objects.create_user(username=data.username, password=data.password)\n    return user\n</code></pre> <ul> <li><code>Schema</code> is a subclass of <code>pydantic.BaseModel</code> that adds some extra functionality.</li> <li>The schema is used to validate the request data before it's passed to the view function.</li> <li>If the data is invalid, a pydantic error will be raised and returned as a response.</li> </ul>"},{"location":"usage/#invalid-request-error-response","title":"Invalid request error response","text":"<pre><code>{\n  \"error\": [\n    {\n      \"type\": \"missing\",\n      \"loc\": [\n        \"username\"\n      ],\n      \"msg\": \"Field required\",\n      \"input\": {\n        \"my_id\": \"1\",\n        \"id\": \"1\"\n      },\n      \"url\": \"https://errors.pydantic.dev/2.6/v/missing\"\n    },\n    {\n      \"type\": \"missing\",\n      \"loc\": [\n        \"email\"\n      ],\n      \"msg\": \"Field required\",\n      \"input\": {\n        \"my_id\": \"1\",\n        \"id\": \"1\"\n      },\n      \"url\": \"https://errors.pydantic.dev/2.6/v/missing\"\n    }\n  ],\n  \"error_count\": 2,\n  \"title\": \"CreateUserSchema\"\n}\n</code></pre>"},{"location":"usage/#query-parameters","title":"Query Parameters","text":"<p>You can also accept query parameters in your view function:</p> <pre><code>@djapify\ndef get_user(request, username: str) -&gt; {200: UserSchema, 404: str}:\n    user = User.objects.get(username=username)\n    return user\n</code></pre>"},{"location":"usage/#allowed-query-parameter-types","title":"Allowed query parameter types","text":"<ul> <li><code>str</code> or <code>Optional[str]</code> or <code>Literal[\"value1\", \"value2\"]</code></li> <li><code>int</code> or <code>Optional[int]</code> or <code>Literal[1, 2, 3]</code></li> <li><code>float</code> or <code>Optional[float]</code></li> <li><code>bool</code></li> <li><code>datetime</code></li> <li><code>constr()</code> or <code>conint()</code> or <code>confloat()</code> or <code>condecimal()</code></li> </ul> <p>If anything else is passed, it will be accepted as a data parameter, not a query parameter. Like: list[str], dict[str, int], etc.</p>"},{"location":"usage/#response","title":"Response","text":"<p>The response is automatically serialized to JSON using the Pydantic model.</p> <pre><code># schemas.py\nfrom djapy import Schema\n\n\nclass UserSchema(Schema):  # or TypedDict\n    username: str\n    email: str\n\n\n# views.py\n@djapify\ndef get_user(request, username: str) -&gt; {200: UserSchema, 404: str}:\n    user = User.objects.get(username=username)\n    return user\n\n\n# urls.py\nurlpatterns = [\n    path('get-user/', views.get_user, name='get-user'),\n]\n</code></pre> <ul> <li>The response will be serialized to JSON using the <code>UserSchema</code> model, if not valid, pydantic error will be raised.</li> <li>If the response is a valid instance of the model, it will be serialized to JSON and returned with a 200 status code.</li> <li>If the response is a string, it will be returned with a 200 status code.</li> </ul>"},{"location":"usage/#invalid-error-response","title":"Invalid error response","text":"<pre><code>{\n  \"error\": [\n    {\n      \"type\": \"missing\",\n      \"loc\": [\n        \"response\",\n        \"message\"\n      ],\n      \"msg\": \"Field required\",\n      \"input\": {\n        \"error\": \"You are not allowed to create a user\"\n      },\n      \"url\": \"https://errors.pydantic.dev/2.6/v/missing\"\n    }\n  ],\n  \"error_count\": 1,\n  \"title\": \"output\"\n}\n</code></pre>"},{"location":"usage/#custom-error-response","title":"Custom error response","text":"<p>You can also return a custom error response, by create error handlers inside <code>djapy_ext/errorhandler.py</code>;</p> <pre><code>from your_custom_exptions.exceptions import MessageOut\n\n\ndef handle_message_out(request, exception: MessageOut):\n    print('Value: Handler executed: ', request)\n    return {\n        'message': exception.message,\n        'alias': exception.alias,\n        'message_type': exception.message_type,\n    }\n</code></pre> <p>Make sure your handler function name is <code>handle_&lt;exception_name&gt;</code></p> <p>And then, you can use it in your view function:</p> <pre><code>@djapify\ndef get_user(request, username: str) -&gt; {200: UserSchema, 404: MessageOut}:\n    user = User.objects.get(username=username)\n    if user:\n        return user\n    else:\n        raise MessageOut('User not found', 'user_not_found', 'error')\n</code></pre> <ul> <li>If exception is raised, the handler will be executed and the response will be returned.</li> </ul>"}]}