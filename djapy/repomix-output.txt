core/
  auth/
    __init__.py
    auth.py
    dec.py
  dec.py
  defaults.py
  labels.py
  mid.py
  parser.py
  response.py
  type_check.py
  typing_utils.py
openapi/
  __init__.py
  defaults.py
  icons.py
  info.py
  openapi_path.py
pagination/
  __init__.py
  base_pagination.py
  cursor_pagination.py
  dec.py
  offset_pagination.py
  page_number_pagination.py
schema/
  __init__.py
  handle.py
  schema.py
  user.py
templates/
  djapy/
    swagger_cdn.html
__init__.py

================================================================
Repository Files
================================================================

================
File: core/auth/__init__.py
================
__all__ = [
    "BaseAuthMechanism",
    "SessionAuth",
    "djapy_auth",
    "djapy_method",
    "base_auth_obj",
]

from djapy.core.auth.auth import BaseAuthMechanism, SessionAuth
from djapy.core.auth.dec import djapy_auth, djapy_method

base_auth_obj = BaseAuthMechanism()

================
File: core/auth/auth.py
================
from django.http import HttpRequest

from djapy.core.defaults import DEFAULT_AUTH_ERROR


class BaseAuthMechanism:
    def __init__(self, permissions: list[str] = None, message_response: dict = None, *args, **kwargs):
        self.message_response = message_response or DEFAULT_AUTH_ERROR
        self.permissions = permissions or []

    def authenticate(self, request: HttpRequest, *args, **kwargs) -> tuple[int, dict] | None:
        pass

    def authorize(self, request: HttpRequest, *args, **kwargs) -> tuple[int, dict] | None:
        pass

    def schema(self):
        return {}

    def app_schema(self):
        return {}

    def set_message_response(self, message_response: dict):
        self.message_response = message_response


class SessionAuth(BaseAuthMechanism):

    def authenticate(self, request: HttpRequest, *args, **kwargs):
        if not request.user.is_authenticated:
            return 403, self.message_response

    def authorize(self, request: HttpRequest, *args, **kwargs):
        if not request.user.is_authenticated or not request.user.has_perms(self.permissions):
            return 403, self.message_response

    def schema(self):
        return {
            "SessionAuth": {
                "type": "apiKey",
                "in": "cookie",
                "name": "sessionid"
            },
            "CSRFTokenAuth": {
                "type": "apiKey",
                "in": "cookie",
                "name": "csrftoken"
            }
        }

    def app_schema(self):
        return {
            "SessionAuth": [],
            "CSRFTokenAuth": []
        }


"""

Something of this syntax. And it could be able to apply pagination details in swagger/OpenAPI too.

@djapify
@djapily_paginated(OffsetLimitPagination)
def related_post(request, search_topic: str) -> {200: list[UserSchema], 401: ErrorMessage}:
    posts = Post.objects.filter(topic__icontains=search_topic)
    return 200, posts

"""

================
File: core/auth/dec.py
================
import inspect
import json
from functools import wraps
from typing import Dict, Callable, List, Type

from django.http import HttpRequest, JsonResponse

from . import BaseAuthMechanism
from ..defaults import ALLOW_METHODS_LITERAL, DEFAULT_METHOD_NOT_ALLOWED_MESSAGE
from djapy.core.auth import SessionAuth


def djapy_auth(auth: Type[BaseAuthMechanism] | BaseAuthMechanism | None = None,
               permissions: List[str] = None,
               msg=None) -> Callable:
    if permissions is None:
        permissions = []
    if not auth:
        auth = SessionAuth

    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(request: HttpRequest, *args, **kwargs):
            return view_func(request, *args, **kwargs)

        if auth and inspect.isclass(auth) and issubclass(auth, BaseAuthMechanism):
            _wrapped_view.auth_mechanism = auth(permissions)
        else:
            _wrapped_view.auth_mechanism = auth
        _wrapped_view.auth_mechanism.set_message_response(msg)

        return _wrapped_view

    if inspect.isfunction(auth):
        return decorator(auth)

    return decorator


def djapy_method(allowed_method_or_list: ALLOW_METHODS_LITERAL | List[ALLOW_METHODS_LITERAL],
                 message_response: Dict[str, str] = None) -> Callable:
    message_response = message_response or DEFAULT_METHOD_NOT_ALLOWED_MESSAGE
    try:
        json.dumps(message_response)
    except TypeError as e:
        raise TypeError(f"Invalid message_response: {message_response}") from e

    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(request: HttpRequest, *args, **kwargs):
            if request.method not in allowed_method_or_list:
                view_func.djapy_message_response = message_response
            return view_func(request, *args, **kwargs)

        if isinstance(allowed_method_or_list, str):
            _wrapped_view.djapy_allowed_method = [allowed_method_or_list]
        else:
            _wrapped_view.djapy_allowed_method = allowed_method_or_list
        return _wrapped_view

    return decorator

================
File: core/dec.py
================
import importlib
import inspect
import json
import types
from functools import wraps
from typing import Callable, Dict, Type, List

from django.core.serializers.json import DjangoJSONEncoder

from djapy.schema import Schema

from django.http import HttpRequest, JsonResponse, HttpResponse, HttpResponseBase
from pydantic import ValidationError, create_model

from .auth import BaseAuthMechanism, base_auth_obj
from .defaults import ALLOW_METHODS_LITERAL, DEFAULT_METHOD_NOT_ALLOWED_MESSAGE, \
    DEFAULT_MESSAGE_ERROR
from djapy.pagination.base_pagination import BasePagination
from .parser import ResponseDataParser, RequestDataParser, get_response_schema_dict
from .labels import REQUEST_INPUT_DATA_SCHEMA_NAME, REQUEST_INPUT_QUERY_SCHEMA_NAME, REQUEST_INPUT_FORM_SCHEMA_NAME, \
    REQUEST_INPUT_SCHEMA_NAME
import logging

__all__ = ['djapify']

from .response import create_json_from_validation_error
from .type_check import is_param_query_type, schema_type, is_data_type
from ..schema.schema import Form, QueryMapperSchema

MAX_HANDLER_COUNT = 3
ERROR_HANDLER_MODULE = "djapy_ext.errorhandler"
ERROR_HANDLER_PREFIX = "handle_"
IN_APP_AUTH_MECHANISM_NAME = "AUTH_MECHANISM"
IN_APP_TAGS_NAME = "TAGS"


def get_required_params(view_func: Callable) -> List[inspect.Parameter]:
    """Extract required parameters from a function signature, skipping the first one."""
    signature = inspect.signature(view_func)

    required_params = []
    for index, (name, param) in enumerate(signature.parameters.items()):
        if param.kind == param.POSITIONAL_OR_KEYWORD and index != 0:
            required_params.append(param)

    return required_params


_errorhandler_functions = []
try:
    _imported_errorhandler = importlib.import_module(ERROR_HANDLER_MODULE)
    _all_handlers = dir(_imported_errorhandler)
    for f in dir(_imported_errorhandler):
        if f.startswith(ERROR_HANDLER_PREFIX):
            _errorhandler_functions.append(getattr(_imported_errorhandler, f))
    if len(_errorhandler_functions) > MAX_HANDLER_COUNT:
        logging.warning(
            f"Errorhandler module should not contain more than {MAX_HANDLER_COUNT} handlers. "
            f"We discourage using more than {MAX_HANDLER_COUNT} handlers in errorhandler module.")
except Exception as e:
    _imported_errorhandler = None


def handle_error(request, exception):
    """
    Handle custom exception assigned;
    :param request: A django request object
    :param exception: An exception object
    """
    for _errorhandler_function in _errorhandler_functions:
        _function_signature = inspect.signature(_errorhandler_function)
        exception_param = _function_signature.parameters.get('exception')
        if exception.__class__ == exception_param.annotation:
            _data_from_error = _errorhandler_function(request, exception)
            if isinstance(_data_from_error, JsonResponse):
                return _data_from_error

            if isinstance(_data_from_error, tuple):
                status, response = _data_from_error
            else:
                status, response = 400, _data_from_error
            if response and isinstance(response, dict):
                try:
                    return JsonResponse(response, status=status, safe=False)
                except TypeError as e:
                    logging.exception(e)
                    return JsonResponse(DEFAULT_MESSAGE_ERROR, status=500)
    return None


def get_passable_tuple(param: inspect.Parameter, annotation=None):
    """
    Get a passable tuple from the parameter
    for the pydantic model creation.
    """
    if annotation is None:
        annotation = param.annotation
    is_empty = param.default is inspect.Parameter.empty
    if is_empty:
        passable_tuple = (annotation, ...)
    else:
        passable_tuple = (annotation, param.default)
    return passable_tuple


def add_query_schema(param, query_schema_dict):
    if param.annotation is inspect.Parameter.empty:
        raise TypeError(f"Parameter `{param.name}` should have a type annotation, because it's required. e.g. "
                        f"`def view_func({param.name}: str):`")
    query_schema_dict[param.name] = get_passable_tuple(param)


def add_content_type_schema(param, form_schema_dict, data_schema_dict, data_type):
    annotation, default = get_passable_tuple(param, data_type)
    has_content_type = hasattr(annotation, 'cvar_c_type')
    if has_content_type:
        if annotation.cvar_c_type == "application/x-www-form-urlencoded":
            form_schema_dict[param.name] = (annotation, default)
        elif annotation.cvar_c_type == "application/json":
            data_schema_dict[param.name] = (annotation, default)
    else:
        data_schema_dict[param.name] = (annotation, default)


def func_path_and_line(view_func):
    func_line = inspect.getsourcelines(view_func)[0]
    return "".join(func_line)


def get_schemas(view_func: callable, extra_query_dict: Dict = None):
    required_params: List[inspect.Parameter] = view_func.required_params
    query_schema_dict = {}
    data_schema_dict = {}
    form_schema_dict = {}
    schema_dict = {}

    already_added_content_types = []
    for param in required_params:
        is_query = is_param_query_type(param)
        if is_query:
            add_query_schema(param, query_schema_dict)
        elif data_type := is_data_type(param):
            add_content_type_schema(param, form_schema_dict, data_schema_dict, data_type)
            already_added_content_types.append(param.annotation)
            if len(set(already_added_content_types)) > 1:
                raise TypeError(
                    f"\n{func_path_and_line(view_func)}"
                    f"Only one content type is allowed in a view function: "
                    f"`{view_func.__name__}`; `{param.name}: {param.annotation}`. "
                    f"\nIt should be either form or data schema."
                )

    schema_dict["query"] = create_model(
        REQUEST_INPUT_QUERY_SCHEMA_NAME,
        **query_schema_dict,
        **extra_query_dict,
        __base__=QueryMapperSchema
    )

    schema_dict["data"] = create_model(
        REQUEST_INPUT_DATA_SCHEMA_NAME,
        **data_schema_dict,
        __base__=Schema
    )

    schema_dict["form"] = create_model(
        REQUEST_INPUT_FORM_SCHEMA_NAME,
        **form_schema_dict,
        __base__=Form
    )

    return schema_dict


def get_auth(view_func: Callable,
             auth: Type[BaseAuthMechanism] | BaseAuthMechanism | None,
             in_app_auth_mechanism: Type[BaseAuthMechanism] | BaseAuthMechanism | None):
    """
    Set the auth mechanism for the view function

    :param view_func: The view function
    :param auth: The auth mechanism
    :param in_app_auth_mechanism: The auth mechanism in the app or views.py
    """
    auth = getattr(view_func, 'auth_mechanism', None) or auth
    if auth == base_auth_obj and in_app_auth_mechanism:
        wrapped_auth = in_app_auth_mechanism
    elif auth is None:
        return base_auth_obj
    else:
        wrapped_auth = auth

    if inspect.isclass(wrapped_auth) and issubclass(wrapped_auth, BaseAuthMechanism):
        wrapped_auth = wrapped_auth()
    else:
        wrapped_auth = wrapped_auth

    if not wrapped_auth:
        wrapped_auth = base_auth_obj

    if not isinstance(wrapped_auth, BaseAuthMechanism):
        raise TypeError(
            f"auth should be a class that inherits from BaseAuthMechanism, not {wrapped_auth.__name__} or {type(wrapped_auth)}")

    return wrapped_auth


def get_in_response_param(required_params: List[inspect.Parameter]):
    for param in required_params:
        if inspect.isclass(param.annotation) and issubclass(param.annotation, HttpResponseBase):
            return param
    return None


def djapify(view_func: Callable = None,
            allowed_method: ALLOW_METHODS_LITERAL | List[ALLOW_METHODS_LITERAL] = "GET",
            openapi: bool = True,
            tags: List[str] = None,
            auth: Type[BaseAuthMechanism] | BaseAuthMechanism | None = base_auth_obj) -> Callable:
    """
    :param view_func: A pydantic model or a view function
    :param allowed_method: A string or a list of strings to check if the view allows the method
    :param openapi: A boolean to check if the view should be included in the openapi schema
    :param tags: A list of strings to tag the view in the openapi schema
    :param auth: A class that inherits from BaseAuthMechanism
    :return: A decorator that will return a JsonResponse with the schema validated data or a message
    """
    global _errorhandler_functions

    def decorator(view_func):
        view_func.required_params = get_required_params(view_func)
        view_func.in_response_param = None
        view_func.in_response_param = get_in_response_param(view_func.required_params)
        view_func_module = importlib.import_module(view_func.__module__)
        in_app_auth_mechanism = getattr(view_func_module, IN_APP_AUTH_MECHANISM_NAME, None)

        @wraps(view_func)
        def _wrapped_view(request: HttpRequest, *args, **view_kwargs):
            authentication_info_tuple = _wrapped_view.auth_mechanism.authenticate(request, *args, **view_kwargs)
            if authentication_info_tuple:
                return JsonResponse(authentication_info_tuple[1], status=authentication_info_tuple[0])

            authorization_info_tuple = _wrapped_view.auth_mechanism.authorize(request, *args, **view_kwargs)
            if authorization_info_tuple:
                return JsonResponse(authorization_info_tuple[1], status=authorization_info_tuple[0])

            djapy_allowed_method = getattr(_wrapped_view, 'djapy_allowed_method', None)
            djapy_message_response = getattr(view_func, 'djapy_message_response', None)

            if request.method not in djapy_allowed_method:
                return JsonResponse(djapy_message_response or DEFAULT_METHOD_NOT_ALLOWED_MESSAGE, status=405)
            try:
                response = HttpResponse(content_type="application/json")
                request_parser = RequestDataParser(request, view_func, view_kwargs)
                _input_data = request_parser.parse_request_data()

                if view_func.in_response_param:
                    _input_data[view_func.in_response_param.name] = response

                response_from_view_func = view_func(request, *args, **_input_data)
                if issubclass(response_from_view_func.__class__, HttpResponseBase):
                    return response_from_view_func

                status_code, response_data = response_from_view_func \
                    if isinstance(response_from_view_func, tuple) else (200, response_from_view_func)

                response_parser = ResponseDataParser(
                    status_code, response_data, schema_dict_returned, request,
                    _input_data
                )
                parsed_data = response_parser.parse_response_data()

                response.status_code = status_code
                response.content = json.dumps(parsed_data, cls=DjangoJSONEncoder)
                return response
            except Exception as exception:
                logging.exception(exception)

                error_response = handle_error(request, exception)
                if error_response:
                    return error_response

                if isinstance(exception, ValidationError):
                    return JsonResponse(create_json_from_validation_error(exception), status=400, safe=False)

                return JsonResponse(DEFAULT_MESSAGE_ERROR, status=500)

        schema_dict_returned = get_response_schema_dict(view_func)

        extra_query_dict = getattr(view_func, 'extra_query_dict', {})  # (name: (type_name_, default))
        response_wrapper = getattr(view_func, 'response_wrapper', None)  # (status, schema)

        if response_wrapper:
            status, wrapper_schema = response_wrapper
            if status in schema_dict_returned:
                schema_dict_returned[status] = wrapper_schema[schema_dict_returned[status]]

        _wrapped_view.djapy = True
        _wrapped_view.openapi = openapi
        _wrapped_view.openapi_tags = tags or getattr(view_func_module, IN_APP_TAGS_NAME, [])

        view_func.schema = _wrapped_view.schema = schema_dict_returned
        _wrapped_view.djapy_message_response = getattr(view_func, 'djapy_message_response', None)
        input_schema = get_schemas(view_func, extra_query_dict)
        _wrapped_view.input_schema = view_func.input_schema = input_schema

        _wrapped_view.auth_mechanism = get_auth(view_func, auth, in_app_auth_mechanism)

        if not getattr(_wrapped_view, 'djapy_allowed_method', None):
            if isinstance(allowed_method, str):
                _wrapped_view.djapy_allowed_method = [allowed_method]
            else:
                _wrapped_view.djapy_allowed_method = allowed_method

        return _wrapped_view

    if callable(view_func):
        return decorator(view_func)

    return decorator

================
File: core/defaults.py
================
from typing import Literal

SESSION_AUTH = "SESSION"
DEFAULT_METHOD_NOT_ALLOWED_MESSAGE = {"message": "Method not allowed", "alias": "method_not_allowed"}
ALLOW_METHODS_LITERAL = Literal["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD", "TRACE", "CONNECT"]
DEFAULT_MESSAGE_ERROR = {"message": "Something went wrong", "alias": "server_error"}
DEFAULT_AUTH_ERROR = {"message": "Unauthorized"}

================
File: core/labels.py
================
JSON_BODY_PARSE_NAME = "body"
REQUEST_INPUT_SCHEMA_NAME = "input"
REQUEST_INPUT_DATA_SCHEMA_NAME = "input_data"
REQUEST_INPUT_FORM_SCHEMA_NAME = "input_form"
REQUEST_INPUT_QUERY_SCHEMA_NAME = "input_query"
RESPONSE_OUTPUT_SCHEMA_NAME = "output"
JSON_OUTPUT_PARSE_NAME = "response"

================
File: core/mid.py
================
import logging

from django.http import JsonResponse

__all__ = ['UHandleErrorMiddleware']


class UHandleErrorMiddleware:
    """
    Middleware to handle exceptions and return a JsonResponse.
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        user_agent = request.headers.get('User-Agent')
        is_browser = 'Mozilla/' in user_agent
        if response.status_code >= 400 and response.headers['Content-Type'] != 'application/json' and not is_browser:
            error_response = {
                "message": "An error occurred while processing your request.",
                "reason": response.reason_phrase,
                "alias": "server_error"
            }
            return JsonResponse(error_response, status=response.status_code)
        return response

================
File: core/parser.py
================
from typing import Dict, Any, Union, Type

from pydantic import create_model, BaseModel, Json
from django.http import HttpRequest

from djapy.schema import Schema
from .response import create_validation_error
from .labels import REQUEST_INPUT_DATA_SCHEMA_NAME, RESPONSE_OUTPUT_SCHEMA_NAME, JSON_OUTPUT_PARSE_NAME, \
    JSON_BODY_PARSE_NAME

__all__ = ['RequestDataParser', 'ResponseDataParser', 'get_response_schema_dict']

from ..schema.schema import json_modal_schema, get_json_dict


class RequestDataParser:
    def __init__(self, request: HttpRequest, view_func, view_kwargs):
        self.view_func = view_func
        self.view_kwargs = view_kwargs
        self.request = request
        self.query_data = {}
        self.line_kwargs = {}
        self.data = {}
        self.form = {}
        self.files = {}

    def parse_request_data(self):
        """
        Parse the request data and validate it with the data model.
        """
        context = {"request": self.request}
        data_schema = self.view_func.input_schema["data"]
        form_schema = self.view_func.input_schema["form"]

        if not data_schema.is_empty():
            request_body = self.request.body.decode()
            if not request_body:
                request_body = "{}"
            data = data_schema.validate_via_request(get_json_dict(request_body), context=context)
            data = data.__dict__
        else:
            data = {}

        if not form_schema.is_empty():
            form = form_schema.validate_via_request(dict(self.request.POST), context=context)
            form = form.__dict__
        else:
            form = {}
        query_data = self.view_func.input_schema["query"].model_validate({
            **self.view_kwargs,
            **dict(self.request.GET)
        }, context=context)

        destructured_object_data = {
            **query_data.__dict__,
            **data,
            **form,
        }
        return destructured_object_data

    def set_request_data(self):
        """
        Returns all the data in the self.request.
        """
        if self.view_kwargs:
            self.line_kwargs.update(self.view_kwargs)
        self.query_data.update(dict(self.request.GET))

        if self.request.method != 'GET':
            if self.request.POST:
                self.form.update(dict(self.request.POST))


class ResponseDataParser:

    def __init__(self, status: int, data: Any, schemas: Dict[int, Union[Type[Schema], type]], request: HttpRequest,
                 input_data: Dict[str, Any] = None):
        self.status = status
        self.data = data
        self.request = request
        self.input_data = input_data
        if not isinstance(schemas, dict):
            raise create_validation_error("Response", "schemas", "invalid_type")
        self.schemas = schemas

    def create_response_model(self):
        """
        Create a Pydantic model on the basis of response schema.
        """
        schema = self.schemas[self.status]
        # Create a dynamic Pydantic model with the schema
        response_model = create_model(
            RESPONSE_OUTPUT_SCHEMA_NAME,
            **{JSON_OUTPUT_PARSE_NAME: (schema, ...)},
            __base__=Schema
        )
        return response_model

    def parse_response_data(self) -> Dict[str, Any]:
        response_model = self.create_response_model()
        validated_obj = response_model.model_validate(
            {JSON_OUTPUT_PARSE_NAME: self.data},
            context={"request": self.request, "input_data": self.input_data}
        )

        # Deconstruct the object data
        destructured_object_data = validated_obj.model_dump(mode="json", by_alias=True)

        return destructured_object_data.get(JSON_OUTPUT_PARSE_NAME)


def get_response_schema_dict(view_func):
    """
    Get the response schema dict from the view function.
    """
    schema_dict_returned = view_func.__annotations__.get('return', None)
    if not isinstance(schema_dict_returned, dict):
        schema_dict_returned = {200: schema_dict_returned}
    return schema_dict_returned

================
File: core/response.py
================
import json

from pydantic import ValidationError
from pydantic_core import InitErrorDetails


def create_json_from_validation_error(exception: ValidationError):
    return {
        'error': json.loads(exception.json()),
        'error_count': exception.error_count(),
        'title': str(exception.title)
    }


def create_validation_error(title, loc_name, _type):
    return ValidationError.from_exception_data(
        title=title,
        line_errors=[
            InitErrorDetails(
                loc=(loc_name,),
                type=_type,
                input=None,
            )
        ],
        input_type="python",
    )

================
File: core/type_check.py
================
import inspect
import types
from inspect import Parameter
from typing import Union, get_args, get_origin, Literal, List, Optional, Annotated

from django.http import HttpResponseBase
from pydantic import BaseModel

from ..schema.handle import Payload

BASIC_TYPES = {
    "str": "string",
    "int": "integer",
    "float": "number",
    "bool": "boolean",
    "datetime": "string",
    "uuid": "uuid",
    "list": "array",
}

BASIC_URL_QUERY_TYPES = {
    **BASIC_TYPES,
    "slug": "string",
}


def get_type_name(type_, *args):
    if get_origin(type_) in [Literal, List, Union, Optional, *args]:
        return get_type_name(get_args(type_)[0]) if get_args(type_) else None
    return type_.__name__ if hasattr(type_, "__name__") else type(type_).__name__


def is_originally_basic_type(annotation):
    return all(get_type_name(type_) in BASIC_TYPES for type_ in get_args(annotation))


def is_union_of_basic_types(annotation):
    """
    Checks if the type hint is a union of basic types. QUERY_BASIC_TYPES
    str | datetime -> True
    str | int -> True
    str | float -> True
    str | bool -> True
    bool | int -> True
    str | float | int -> True
    str | float | int | bool -> True
    str | list[int] -> False
    str | list[str] -> False
    str | dict -> False
    """
    if not isinstance(annotation, types.UnionType):
        return False
    return is_originally_basic_type(annotation)


def is_base_query_type(annotation):
    """
    Basically checks if the parameter is a basic query type.
    """
    if get_type_name(annotation) in BASIC_TYPES:
        return True
    if is_union_of_basic_types(annotation):
        return True
    return False


def is_annotated_of_basic_types(annotation):
    args = get_args(annotation)
    origin = get_origin(annotation)

    if origin is Annotated:
        inner_type = args[0]  # Get the inner original type
        if is_base_query_type(inner_type):
            return True
    return False


def is_param_query_type(param: Parameter):
    """
    Basically checks if the parameter is a basic query type.
    """

    annotation = param.annotation
    if is_base_query_type(annotation):
        return True
    if is_annotated_of_basic_types(annotation):
        return True

    return False


def basic_query_schema(param: Parameter | str, default=None):
    type_name = None
    if isinstance(param, str):
        type_name = BASIC_URL_QUERY_TYPES.get(param)
    elif param:
        type_name = BASIC_TYPES.get(param.annotation.__name__)
    return {"type": type_name or default}


def schema_type(param: Parameter | object):
    if isinstance(param, Parameter):
        type_object_ = param.annotation
    else:
        type_object_ = param
    if inspect.isclass(type_object_) and (issubclass(type_object_, BaseModel) or isinstance(type_object_, BaseModel)):
        return type_object_
    return None


def is_django_type(param: Parameter):
    """
    Checks if the parameter is a django type, or payload[str, int, float, bool]
    """
    return inspect.isclass(param.annotation) and issubclass(param.annotation, HttpResponseBase)


def is_data_type(param: Parameter):
    """
    Checks if the parameter is a data type, or payload[str, int, float, bool]
    """
    if is_django_type(param):
        return None
    if isinstance(param.annotation, Payload):
        return param.annotation.unquery_type
    return param.annotation

================
File: core/typing_utils.py
================
from typing import TypeVar

G_TYPE = TypeVar('G_TYPE')

================
File: openapi/__init__.py
================
import json
from pathlib import Path
from typing import Optional, TypedDict

from django.http import JsonResponse, HttpRequest, HttpResponse
from django.urls import URLPattern, get_resolver, path, reverse

from .defaults import ABS_TPL_PATH
from .icons import icons
from .info import Info, Contact, License
from .openapi_path import OpenAPI_Path


class PassedBaseUrl(TypedDict):
    url: str
    description: str


class OpenAPI:
    openapi = "3.1.0"
    description = "Powerful djapy powered API, built with Django and Pydantic"
    info = Info("Djapy", "1.0.0", description)
    paths = {}
    components = {"schemas": {}}
    definitions = {}
    tags = []
    security_schema = {}
    security = {}
    passed_base_urls = None
    contact = None
    license = None

    def __init__(self):
        self.resolved_url = get_resolver()

    @staticmethod
    def is_djapy_openapi(view_func):
        return getattr(view_func, 'djapy', False) and getattr(view_func, 'openapi', False)

    def set_path_and_exports(self, openapi_path_: OpenAPI_Path):
        if openapi_path_.export_definitions:
            self.definitions.update(path.export_definitions)
        if openapi_path_.export_components:
            self.components["schemas"].update(openapi_path_.export_components)
        if openapi_path_.export_security_schemes:
            self.components["securitySchemes"] = {
                **self.components.get("securitySchemes", {}),
                **openapi_path_.export_security_schemes
            }
        if openapi_path_.export_tags:
            self.tags.extend(openapi_path_.export_tags)
        if getattr(openapi_path_.url_pattern.callback, 'openapi', False):
            self.paths[openapi_path_.path] = openapi_path_.dict()

    def generate_paths(self, url_patterns: list[URLPattern], parent_url_patterns=None):
        if parent_url_patterns is None:
            parent_url_patterns = []
        for url_pattern in url_patterns:
            try:
                if self.is_djapy_openapi(url_pattern.callback):
                    openapi_path_ = OpenAPI_Path(url_pattern, parent_url_patterns)
                    self.set_path_and_exports(openapi_path_)
                if hasattr(url_pattern, 'url_patterns'):
                    self.generate_paths(url_pattern.url_patterns, parent_url_patterns + [url_pattern])
            except Exception as e:
                if url_pattern.callback:
                    print(f"[x] Error in generating paths for view: `{url_pattern.callback.__name__}`;")
                raise e

    def dict(self, request: HttpRequest):
        self.generate_paths(self.resolved_url.url_patterns)
        servers = [
            {'url': request.build_absolute_uri('/'), 'description': 'Local server'},
        ]
        if self.passed_base_urls:
            servers.extend(self.passed_base_urls)
        return {
            'openapi': self.openapi,
            'info': self.info.dict(),
            'paths': self.paths,
            'components': self.components,
            '$defs': self.definitions,
            'tags': self.tags,
            'security': self.security,
            'servers': servers
        }

    def set_basic_info(
            self, title: str, description, version="1.0.0",
            tags_info=None, security_schema: dict = None,
            security: dict = None,
            passed_base_url: Optional[list[PassedBaseUrl]] = None,
            contact: Contact = None,
            license_: License = None,
            site_name="Djapy",
    ):
        self.info.title = title
        self.info.cvar_describe = description
        self.info.version = version
        self.info.contact = contact
        self.info.site_name = site_name
        self.info.license = license_
        self.tags.extend(tags_info or [])
        self.security_schema = security_schema or {}
        self.security = security or {}
        self.passed_base_urls = passed_base_url

    def get_openapi(self, request):
        openapi_dict = self.dict(request)
        return JsonResponse(openapi_dict)

    def render_swagger_ui(self, request):
        openapi_json_url = reverse('djapy:openapi')
        absolute_openapi_json_url = request.build_absolute_uri(openapi_json_url)
        is_dark_mode = request.COOKIES.get("dark_mode", "false") == "true"
        return _render_cdn_template(request, ABS_TPL_PATH / 'swagger_cdn.html', {
            "swagger_settings": json.dumps({
                "url": absolute_openapi_json_url,
                "layout": "BaseLayout",
                "deepLinking": "true",
            }),
            "api": {
                "title": self.info.title,
                "site_name": self.info.site_name,
            },
            "dark_mode": is_dark_mode,
            "icons": icons,
            "active_icon": icons["light_mode" if is_dark_mode else "dark_mode"],
            "add_csrf": True,
            "csrf_token": request.COOKIES.get("csrftoken"),
        })

    def get_urls(self):
        return [
            path('openapi.json', self.get_openapi, name='openapi'),
            path('', self.render_swagger_ui, name='swagger')
        ]

    @property
    def urls(self):
        return self.get_urls(), "djapy", "djapy-openapi"


def _render_cdn_template(
        request: HttpRequest, template_path: Path, context: Optional[dict] = None
) -> HttpResponse:
    "this is helper to find and render html template when djapy is not in INSTALLED_APPS"
    from django.template import RequestContext, Template

    tpl = Template(template_path.read_text())
    html = tpl.render(RequestContext(request, context))
    return HttpResponse(html)


openapi = OpenAPI()

================
File: openapi/defaults.py
================
from pathlib import Path

__all__ = ['REF_MODAL_TEMPLATE', 'ABS_TPL_PATH']
REF_MODAL_TEMPLATE = "#/components/schemas/{model}"
ABS_TPL_PATH = Path(__file__).parent.parent / "templates/djapy/"

================
File: openapi/icons.py
================
icons = {
    "light_mode": """
    <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24">
        <path fill="currentColor" d="M18 12a6 6 0 1 1-12 0a6 6 0 0 1 12 0"/>
        <path fill="currentColor" fill-rule="evenodd" 
        d="M12 1.25a.75.75 0 0 1 .75.75v1a.75.75 0 0 1-1.5 0V2a.75.75 0 0 1 .75-.75M4.399 4.399a.75.75 0 0 1 1.06 0l.393.392a.75.75 0 0 1-1.06 1.061l-.393-.393a.75.75 0 0 1 0-1.06m15.202 0a.75.75 0 0 1 0 1.06l-.393.393a.75.75 0 0 1-1.06-1.06l.393-.393a.75.75 0 0 1 1.06 0M1.25 12a.75.75 0 0 1 .75-.75h1a.75.75 0 0 1 0 1.5H2a.75.75 0 0 1-.75-.75m19 0a.75.75 0 0 1 .75-.75h1a.75.75 0 0 1 0 1.5h-1a.75.75 0 0 1-.75-.75m-2.102 6.148a.75.75 0 0 1 1.06 0l.393.393a.75.75 0 1 1-1.06 1.06l-.393-.393a.75.75 0 0 1 0-1.06m-12.296 0a.75.75 0 0 1 0 1.06l-.393.393a.75.75 0 1 1-1.06-1.06l.392-.393a.75.75 0 0 1 1.061 0M12 20.25a.75.75 0 0 1 .75.75v1a.75.75 0 0 1-1.5 0v-1a.75.75 0 0 1 .75-.75" clip-rule="evenodd"/>
    </svg>
    """,
    "dark_mode": """
    <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M11.535 3.519a1 1 0 0 0-1.061-1.403C5.675 2.852 2 6.996 2 12c0 5.523 4.477 10 10 10s10-4.477 10-10a10.4 10.4 0 0 0-.004-.28a1 1 0 0 0-1.571-.793a6 6 0 0 1-8.89-7.409" clip-rule="evenodd"/></svg>
    """
}

================
File: openapi/info.py
================
from typing_extensions import TypedDict


class License(TypedDict):
    name: str
    url: str
    identifier: str


class Contact(TypedDict):
    name: str
    url: str
    email: str


class Info:
    def __init__(self, title: str, version: str, description: str, site_name="Djapy"):
        self.title = title
        self.version = version
        self.cvar_describe = description
        self.license = None
        self.contact = None
        self.site_name = site_name

    def dict(self):
        return {
            "title": self.title,
            "version": self.version,
            "description": self.cvar_describe,
            "license": self.license,
            "contact": self.contact
        }

================
File: openapi/openapi_path.py
================
import inspect
import re
from http.client import responses

from django.urls import URLPattern
from pydantic import create_model

from .defaults import REF_MODAL_TEMPLATE
from djapy.core.type_check import schema_type, basic_query_schema
from djapy.schema import Schema

__all__ = ['OpenAPI_Path']


class OpenAPI_Path:
    def set_docstrings(self):
        docstring = inspect.getdoc(self.view_func)
        if docstring:
            lines = docstring.split('\n')
            self.summary = lines[0]
            self.explanation = '\n'.join(lines[1:])
        else:
            self.summary = self.view_func.__name__
            self.explanation = ""

    def set_tags(self):
        explicit_tags = (
                getattr(self.view_func, 'openapi_tags', None)
                or self.openapi_tags
                or [self.view_func.__module__]
        )
        self.tags = explicit_tags

    def set_security(self):
        self.security.append(self.view_func.auth_mechanism.app_schema())
        self.export_security_schemes.update(self.view_func.auth_mechanism.schema())  # AuthMechanism.schema

    def __init__(self, url_pattern: URLPattern, parent_url_pattern: list[URLPattern] = None):
        self.parent_url_pattern = parent_url_pattern or []
        self.view_func = url_pattern.callback
        self.openapi_tags = getattr(self.view_func, 'openapi_tags', [])
        self.export_tags = None
        self.export_security_schemes = {}
        self.export_components = {}
        self.export_definitions = {}

        self.security = []
        self.tags = None
        self.explanation = None
        self.summary = None
        self.url_pattern = url_pattern

        self.operation_id = f"{self.view_func.__module__}.{self.view_func.__name__}"
        self.methods = url_pattern.callback.djapy_allowed_method
        self.parameters_keys = []
        self.request_body = {}
        self.responses = {}
        self.parameters = []
        self.path = None
        self.set_path()
        self.set_security()
        self.set_docstrings()
        self.set_tags()
        self.set_parameters()
        self.set_responses()
        self.set_request_body()

    def set_request_body(self):
        for schema in [self.view_func.input_schema["data"], self.view_func.input_schema["form"]]:
            if single_schema := schema.single():
                schema = single_schema[1]
            prepared_schema = schema.model_json_schema(ref_template=REF_MODAL_TEMPLATE)
            if "$defs" in prepared_schema:
                self.export_components.update(prepared_schema.pop("$defs"))
            content = prepared_schema if prepared_schema["properties"] else {}
            if content:
                if not self.request_body.get("content"):
                    self.request_body["content"] = {schema.cvar_c_type: {"schema": content}}
                if not self.request_body["content"].get(schema.cvar_c_type):
                    self.request_body["content"][schema.cvar_c_type] = {"schema": content}
                if not self.request_body["content"][schema.cvar_c_type].get("schema"):
                    self.request_body["content"][schema.cvar_c_type]["schema"] = content

                self.request_body["content"][schema.cvar_c_type]["schema"] = content

    @staticmethod
    def make_parameters(name, schema, required, in_="query"):
        return {
            "name": name,
            "in": in_,
            "required": required,
            "schema": schema
        }

    def set_parameters(self):
        self.set_parameters_from_parent_url_pattern()
        self.set_parameters_from_required_params()

    def set_parameters_from_required_params(self):
        prepared_query_schema = self.view_func.input_schema["query"].model_json_schema(ref_template=REF_MODAL_TEMPLATE)
        # possibly, this should be a property, no refs
        if prepared_query_schema["properties"]:
            for name, schema in prepared_query_schema["properties"].items():
                if name in self.parameters_keys:
                    continue
                # is_url_param = re.search(name, str(self.url_pattern.pattern)) # this patter is flawed
                pattern = r'[<](?:(?P<type>\w+?):)?(?P<name>\w+)[>]'
                is_url_param = re.search(pattern, str(self.url_pattern.pattern))
                required_ = name in prepared_query_schema.get("required", [])
                parameter = self.make_parameters(name, schema, required_, "path" if is_url_param else "query")
                self.parameters_keys.append(name)
                self.parameters.append(parameter)

    def set_parameters_from_parent_url_pattern(self):
        for url_pattern in self.parent_url_pattern + [self.url_pattern]:
            pattern = r'[<](?:(?P<type>\w+?):)?(?P<name>\w+)[>]'
            if match := re.search(pattern, str(url_pattern.pattern)):
                _type, name = match.groups()
                schema = basic_query_schema(_type)
                parameter = self.make_parameters(name, schema, True, "path")
                self.parameters_keys.append(name)
                self.parameters.append(parameter)

    def set_path(self):
        url_path_string = ""
        for url_pattern in self.parent_url_pattern or []:
            url_path_string += self.format_pattern(url_pattern)
        url_path_string += self.format_pattern(self.url_pattern)
        if not url_path_string.startswith('/'):
            url_path_string = '/' + url_path_string
        self.path = url_path_string

    @staticmethod
    def format_pattern(url_pattern: URLPattern) -> str:
        pattern = r'[<](?:(?P<type>\w+?):)?(?P<variable>\w+)[>]'
        match = re.search(pattern, str(url_pattern.pattern))
        if match:
            return re.sub(pattern, '{' + match.group('variable') + '}', str(url_pattern.pattern))
        else:
            return str(url_pattern.pattern)

    @staticmethod
    def make_description_from_status(status: int) -> str:
        return responses.get(status, "Unknown")

    def set_responses(self):
        for status, schema in self.url_pattern.callback.schema.items():
            description = ""
            if schema_type(schema):
                if isinstance(schema, Schema) and schema.Info.cvar_describe:
                    description = schema.Info.cvar_describe.get(status, "Unknown")
            if not description:
                description = self.make_description_from_status(status)
            response_model = create_model(
                'openapi_response_model',
                **{'response': (schema, ...)},
                __base__=Schema
            )

            prepared_schema = response_model.model_json_schema(ref_template=REF_MODAL_TEMPLATE, mode='serialization')
            if "$defs" in prepared_schema:
                self.export_components.update(prepared_schema.pop("$defs"))
            content = prepared_schema['properties']['response']
            self.responses[str(status)] = {
                "description": description,
                "content": {"application/json": {"schema": content}}
            }

    def dict(self):

        return {
            method.lower(): {
                "summary": self.summary,
                "description": self.explanation,
                "operationId": self.operation_id + f".{method.lower()}",
                "responses": self.responses,
                "parameters": self.parameters,
                "requestBody": self.request_body,
                "tags": self.tags,
                "security": self.security
            } for method in self.methods
        }

================
File: pagination/__init__.py
================
from .base_pagination import BasePagination
from .offset_pagination import OffsetLimitPagination
from .page_number_pagination import PageNumberPagination
from .cursor_pagination import CursorPagination
from .dec import paginate

__all__ = ["OffsetLimitPagination", "PageNumberPagination", "CursorPagination", "BasePagination",
           "paginate"]

================
File: pagination/base_pagination.py
================
from typing import Generic

from djapy.schema import Schema
from djapy.core.typing_utils import G_TYPE


class BasePagination:
    """
    Basic pagination with no features implemented. This is the structure of the pagination.
    """

    query = []

    class response(Schema, Generic[G_TYPE]):
        pass

================
File: pagination/cursor_pagination.py
================
from typing import Generic, Literal
from django.db.models import QuerySet
from pydantic import model_validator, conint

from djapy.pagination.base_pagination import BasePagination
from djapy.core.typing_utils import G_TYPE
from djapy.schema import Schema

__all__ = ["CursorPagination"]


class CursorPagination(BasePagination):
    """Cursor-based pagination."""

    query = [
        ('cursor', conint(ge=0) | Literal['null'] | None, None),
        ('limit', conint(ge=1), 1),
        ('ordering', Literal['asc', 'desc'], 'asc'),  # the ordering can be 'asc', 'desc', or None
    ]

    class response(Schema, Generic[G_TYPE]):
        items: G_TYPE
        cursor: int | None
        limit: int
        ordering: Literal['asc', 'desc']
        has_next: bool

        @model_validator(mode="before")
        def make_data(cls, queryset, info):
            if not isinstance(queryset, QuerySet):
                raise ValueError("The result should be a QuerySet")

            cursor = info.context['input_data']['cursor']
            limit = info.context['input_data']['limit']
            ordering = info.context['input_data']['ordering']
            if cursor == 'null':
                cursor = None

            is_cursor_empty = cursor is None
            # apply ordering to the queryset
            if ordering == 'desc':
                queryset = queryset.order_by('-id')  # descending order
            else:  # default to ascending order
                queryset = queryset.order_by('id')  # ascending order

            if not queryset.exists():
                return {
                    "items": [],
                    "cursor": None,
                    "limit": limit,
                    "has_next": False,
                    "ordering": ordering
                }

            if is_cursor_empty:
                cursor = queryset.first().id

            # apply cursor to the queryset
            query_search = {}  # for ascending order
            if is_cursor_empty and ordering == 'desc':
                query_search = {'id__lte': cursor}
            elif is_cursor_empty and ordering == 'asc':
                query_search = {'id__gte': cursor}
            elif ordering == 'desc':
                query_search = {'id__lt': cursor}
            else:
                query_search = {'id__gt': cursor}

            queryset_with_cursor = queryset.filter(**query_search)
            has_next = queryset_with_cursor.count() > limit

            # get subset
            queryset_subset = list(queryset_with_cursor[:limit])

            # set new cursor
            if queryset_subset:
                new_cursor = queryset_subset[-1].id
                cursor = new_cursor if has_next else None
            else:
                cursor = None

            return {
                "items": queryset_subset,
                "cursor": cursor,
                "limit": limit,
                "has_next": has_next,
                "ordering": ordering
            }

================
File: pagination/dec.py
================
import types
from functools import wraps
from typing import Type, Callable

from django.http import HttpRequest

from djapy.pagination import BasePagination, OffsetLimitPagination


def paginate(pagination_class: Type[BasePagination] | None = None) -> Callable:
    if pagination_class is None:
        pagination_class = OffsetLimitPagination

    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(request: HttpRequest, *args, **kwargs):
            return view_func(request, *args, **kwargs)

        extra_query_dict = {}
        if pagination_class:
            if not issubclass(pagination_class, BasePagination):
                pagination_type_invalid_msg = (f"pagination_class should be a class that inherits from BasePagination, "
                                               f"not {pagination_class.__name__} or {type(pagination_class)}")
                raise TypeError(pagination_type_invalid_msg)

            extra_query_dict = {
                name: (type_name_, default)
                for name, type_name_, default in pagination_class.query
            }

        _wrapped_view.response_wrapper = (200, pagination_class.response)
        _wrapped_view.extra_query_dict = extra_query_dict

        return _wrapped_view

    if pagination_class and isinstance(pagination_class, types.FunctionType):
        view_func = pagination_class
        pagination_class = OffsetLimitPagination
        return decorator(view_func)

    return decorator

================
File: pagination/offset_pagination.py
================
import math

from typing import Generic
from django.db.models import QuerySet
from pydantic import model_validator, conint

from djapy.pagination import BasePagination
from djapy.core.typing_utils import G_TYPE
from djapy.schema import Schema

__all__ = ["OffsetLimitPagination"]


class OffsetLimitPagination(BasePagination):
    """Pagination based on offset and limit."""

    query = [
        ('offset', conint(ge=0), 0),
        ('limit', conint(gt=0), 10)
    ]

    def __repr__(self):
        return f"OffsetLimitPagination({self.query})"

    class response(Schema, Generic[G_TYPE]):
        items: G_TYPE
        offset: int
        limit: int
        has_next: bool
        has_previous: bool
        total_pages: int

        def __repr__(self):
            return f"{G_TYPE.__name__} with offset {self.offset} and limit {self.limit}"

        @model_validator(mode="before")
        def make_data(cls, queryset, info):
            if not isinstance(queryset, QuerySet):
                raise ValueError("The result should be a QuerySet")

            input_data = info.context['input_data']
            offset = input_data['offset']
            limit = input_data['limit']

            if len(queryset) == 0 or offset > len(queryset):
                return {
                    "items": [],
                    "offset": offset,
                    "limit": limit,
                    "has_next": False,
                    "has_previous": False,
                    "total_pages": 0,
                }

            queryset_subset = queryset[offset:offset + limit]

            return {
                "items": queryset_subset,
                "offset": offset,
                "limit": limit,
                "has_next": len(queryset_subset) == limit,
                "has_previous": offset > 0,
                "total_pages": int(math.ceil(len(queryset) / limit)),
            }

================
File: pagination/page_number_pagination.py
================
from typing import Generic

from django.core.paginator import Paginator, EmptyPage
from django.db.models import QuerySet
from pydantic import model_validator

from djapy.pagination import BasePagination
from djapy.core.typing_utils import G_TYPE
from djapy.schema import Schema

from pydantic import conint

__all__ = ["PageNumberPagination"]


class PageNumberPagination(BasePagination):
    """Pagination based on Page Number."""

    query = [
        ('page_number', conint(ge=1), 1),
        ('page_size', conint(gt=0), 10)
    ]

    class response(Schema, Generic[G_TYPE]):
        items: G_TYPE = []
        has_next: bool = False
        has_previous: bool = False
        num_pages: int = 0
        current_page: int = 0

        @model_validator(mode="before")
        def make_data(cls, queryset, info):
            if not isinstance(queryset, QuerySet):
                raise ValueError("The result should be a QuerySet")

            page_number = info.context['input_data']['page_number']
            page_size = info.context['input_data']['page_size']

            paginator = Paginator(queryset, page_size)

            try:
                page_obj = paginator.page(page_number)
            except EmptyPage:
                return {
                    "items": [],
                    "has_next": False,
                    "has_previous": False,
                    "num_pages": paginator.num_pages,
                    "current_page": page_number
                }

            return {
                "items": page_obj.object_list,
                "has_next": page_obj.has_next(),
                "has_previous": page_obj.has_previous(),
                "num_pages": paginator.num_pages,
                "current_page": page_number
            }

================
File: schema/__init__.py
================
__all__ = ['Schema', 'Form', 'QueryList', 'Outsource', 'payload', 'uni_schema']

from djapy.schema.handle import payload, uni_schema
from djapy.schema.schema import Schema, Outsource, Form, QueryList

================
File: schema/handle.py
================
__all__ = ['payload', 'uni_schema', 'status_codes']

from http.client import responses
from typing import Type, TypedDict

from .schema import Schema
from djapy.core.typing_utils import G_TYPE


class StatusCodes:
    def __init__(self):
        self.success_2xx = {code for code in range(200, 300) if code in responses}
        self.error_4xx = {code for code in range(400, 500) if code in responses}
        self.server_error_5xx = {code for code in range(500, 600) if code in responses}

    @property
    def all(self):
        return {code for code in self.success_2xx | self.error_4xx | self.server_error_5xx}


class ReSchema:
    """
    This class is used to generate response schemas for different status codes.
    """

    def __call__(self, schema: Schema | Type[TypedDict],
                 status_set=None):
        """
        :param schema: The schema to be used.
        :param status_set: The status codes to be used. Default is None. If None, all status codes are used `(2xx, 4xx, 5xx)`.
        """
        if status_set is None:
            status_set = {code for code in status_codes.all}
        return {code: schema for code in status_set}

    def success_2xx(self, schema):
        return self.__call__(schema, status_codes.success_2xx)

    def error_4xx(self, schema):
        return self.__call__(schema, status_codes.error_4xx)

    def server_error_5xx(self, schema):
        return self.__call__(schema, status_codes.server_error_5xx)

    def all(self, schema):
        return self.__call__(schema, status_codes.all)


class Payload:
    unquery_type: G_TYPE | None = None

    def __call__(self, type_: G_TYPE) -> G_TYPE:
        """
        Enforces any type to be received as a payload.
        """
        self.unquery_type = type_
        return self


payload = Payload()
uni_schema = ReSchema()  # uni_schema is short for unified schema
status_codes = StatusCodes()

================
File: schema/schema.py
================
__all__ = ['Schema', 'Outsource', 'QueryList', 'ImageUrl', 'get_json_dict', 'Form', 'QueryMapperSchema']

import inspect
import typing
from typing import Any, Annotated, List, Union, get_origin, ClassVar

from django.db.models import QuerySet
from django.db.models.fields.files import ImageFieldFile
from pydantic import BaseModel, model_validator, ConfigDict, BeforeValidator, create_model, Json
from pydantic.functional_validators import field_validator

from pydantic_core.core_schema import ValidationInfo

from djapy.core import type_check
from djapy.core.labels import REQUEST_INPUT_DATA_SCHEMA_NAME, JSON_BODY_PARSE_NAME
from djapy.core.typing_utils import G_TYPE


class Schema(BaseModel):
    """
    Enhance to automatically detect many-to-many fields for serialization.
    """
    model_config = ConfigDict(validate_default=True, validate_assignment=True, from_attributes=True,
                              arbitrary_types_allowed=True)
    cvar_c_type: ClassVar = "application/json"
    cvar_describe: ClassVar[dict] = {}  # this is a description about the class

    @classmethod
    def validate_via_request(cls, json_data, context: dict):
        """
        Validate the model using the request object.
        """
        if single_schema := cls.single():
            single_schema_key, single_schema_model = single_schema
            json_data = {single_schema_key: json_data}

        return cls.model_validate(json_data, context=context)

    @classmethod
    def single(cls) -> bool | tuple[str, 'Schema']:
        if len(cls.__annotations__) == 1:
            single_data_schema_obj = list(cls.__annotations__.values())[0]
            if type_check.schema_type(single_data_schema_obj):
                single_data_schema_key = list(cls.__annotations__.keys())[0]
                return single_data_schema_key, single_data_schema_obj
        return False

    @classmethod
    def is_empty(cls):
        return not cls.__annotations__


json_modal_schema = create_model(
    REQUEST_INPUT_DATA_SCHEMA_NAME,
    **{JSON_BODY_PARSE_NAME: (Json, ...)},
    __base__=Schema
)


def get_json_dict(to_jsonify_text: str):
    return json_modal_schema.model_validate({
        JSON_BODY_PARSE_NAME: to_jsonify_text
    }).dict().get(JSON_BODY_PARSE_NAME)


class QueryMapperSchema(Schema):
    """
    Multiple query or formdata like data can be validated using this model.
    """
    cvar_c_type = "_query_mapper"

    @field_validator("*", mode="before")
    def __field_validator__(cls, value: Any, info: ValidationInfo):
        field_type = cls.model_fields.get(info.field_name)
        origin = get_origin(field_type.annotation)
        if (inspect.isclass(origin) and issubclass(origin, typing.Iterable)
                and typing.get_args(field_type.annotation) != ()):
            return value
        if isinstance(value, list):  # Django's QueryDict {key: [value]} is converted to list.
            return value[0]
        return value


class Form(QueryMapperSchema):
    """
    Post form data can be validated using this model.
    """
    cvar_c_type = "application/x-www-form-urlencoded"


class Outsource(BaseModel):
    """
    Allows the model to have a source object, info object and context object.
    Specially useful for validation and checking on @computed_fields.
    """
    _obj = None
    _info: ValidationInfo = None
    _ctx: dict = None

    @model_validator(mode="wrap")
    def __validator__(cls,
                      val: Any,
                      next_: typing.Callable[[Any], typing.Self],
                      validation_info: ValidationInfo
                      ) -> typing.Self:
        obj = next_(val)
        obj._obj = val
        obj._info = validation_info
        obj._ctx = validation_info.context
        return obj


def query_list_validator(value: QuerySet):
    """
    Validator to ensure the Django QuerySet is converted to an iterable.
    """
    return value.all()


QueryList = Annotated[List[G_TYPE], BeforeValidator(query_list_validator)]


def image_field_file_validator(value: ImageFieldFile):
    """
    Validator to ensure the ImageFieldFile is converted to a URL.
    """
    if value:
        return value.url
    return None


ImageUrl = Annotated[Union[None, str], BeforeValidator(image_field_file_validator)]

================
File: schema/user.py
================
from pydantic import field_validator

from djapy.schema import Schema


class PermissionSchema(Schema):
    codename: str
    name: str


class UserSchema(Schema):
    id: int
    username: str
    user_permissions: list[PermissionSchema]
    first_name: str
    last_name: str

    @field_validator('user_permissions', mode='before')
    def validate_user_permissions(cls, value):
        all_permissions = value.all()
        return all_permissions

================
File: templates/djapy/swagger_cdn.html
================
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swagger-ui@5.10.0/dist/swagger-ui.css"
          integrity="sha256-IgNmYaATqY6z6AuD6hvz9XN0OyeAc94gsTa+lK8ka1Y=" crossorigin="anonymous">
    <link rel="shortcut icon" href="https://djapy.io/images/icons/faviconGreen.svg">
    <title>{{ api.title }} | {{ api.site_name }}</title>
    {# if request has ?darkmode, add dark mode #}

    <style>
        /* Fast dark mode https://github.com/swagger-api/swagger-ui/issues/5327 */

        body.dark {
            background: #04090e;
        }

        body.dark .swagger-ui {
            filter: invert(90%) hue-rotate(180deg);
        }

        body.dark .swagger-ui .microlight {
            filter: invert(100%) hue-rotate(180deg);
        }

        .swagger-ui .info .title {
            display: flex;
            align-items: start;
        }


        #dark-mode-toggle {
            border-radius: 45%;
            height: 35px;
            width: 35px;
            margin-left: auto;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            background: #e7faf4;
            border: 2px solid #95afab;
            color: #181816;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #dark-mode-toggle:active {
            transform: scale(0.9);
        }
    </style>
</head>
<body class="{% if dark_mode %}dark{% endif %}">


<script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"></script>

<div id="swagger-ui">
</div>

<script type="application/json" id="swagger-settings">
    {{ swagger_settings | safe }}
</script>

<script>

    const button = document.createElement('button');
    button.id = 'dark-mode-toggle';
    button.innerHTML = `{{ active_icon | safe }}`;
    button.onclick = () => {
        const darkMode = document.body.classList.contains('dark');
        if (darkMode) {
            document.body.classList.remove('dark');
            document.cookie = 'dark_mode=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
            button.innerHTML = `{{ icons.dark_mode | safe }}`;
        } else {
            document.body.classList.add('dark');
            document.cookie = 'dark_mode=true; path=/';
            button.innerHTML = `{{ icons.light_mode | safe }}`;
        }
    };

    const configJson = document.getElementById("swagger-settings").textContent;
    const configObject = JSON.parse(configJson);

    configObject.dom_id = "#swagger-ui";
    configObject.presets = [
        SwaggerUIBundle.presets.apis,
        SwaggerUIBundle.SwaggerUIStandalonePreset
    ];

    {% if add_csrf %}
        configObject.requestInterceptor = (req) => {
            req.headers['X-CSRFToken'] = "{{csrf_token}}";
            return req;
        };
    {% endif %}

    const ui = SwaggerUIBundle(configObject);

    const observer = new MutationObserver(async (mutations) => {
        for (const mutation of mutations) {
            if (mutation.addedNodes.length) {
                const titleSec = document.querySelector('h2.title');
                if (titleSec) {
                    titleSec.appendChild(button);
                    observer.disconnect();
                }
            }
        }
    });

    observer.observe(document, {childList: true, subtree: true});
</script>
</body>
</html>

================
File: __init__.py
================
from .core.auth import djapy_method, djapy_auth
from djapy.openapi import openapi
from .core.dec import djapify
from .core.mid import UHandleErrorMiddleware
from .schema import Schema
from .core.auth import SessionAuth, BaseAuthMechanism

__all__ = ['djapify', 'openapi', 'djapy_auth', 'djapy_method', 'Schema', 'UHandleErrorMiddleware',
           'SessionAuth', 'BaseAuthMechanism']
